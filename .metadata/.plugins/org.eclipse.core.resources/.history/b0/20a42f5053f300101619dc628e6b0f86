package com.Inventoryservice.Service;

import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Service;
import com.Inventoryservice.Entity.Inventory;
import com.Inventoryservice.Repository.InventoryRepository;
import com.Inventoryservice.dto.InventoryCheckRequestDTO;
import com.Inventoryservice.dto.InventoryCheckResponseDTO;
import com.Inventoryservice.dto.InventoryCreateRequestDTO;
import com.Inventoryservice.dto.InventoryReduceRequestDTO;
import com.Inventoryservice.dto.InventoryResponseDTO;
import com.Inventoryservice.dto.InventoryRestockRequestDTO;

import jakarta.annotation.PostConstruct;
import jakarta.transaction.Transactional;
@Service
public class Inventoryservice {
	 private final InventoryRepository inventoryRepo;
	 private final ProductClient productClient;
	 private final InventoryRedisService redisService;
	 public Inventoryservice (InventoryRepository inventoryRepo,ProductClient productClient,InventoryRedisService redisService){
		 this.inventoryRepo=inventoryRepo;
		 this.productClient=productClient;
		 this.redisService=redisService;
	 }
	public InventoryResponseDTO addNewProductInInventory(InventoryCreateRequestDTO request) {
		Inventory inventory=new Inventory();
		inventory.setProductId(request.getProductId());
		inventory.setQuantity(request.getQuantity());
		inventory.setProductName(request.getProductName());
		inventory.updateStatus();
		inventory.setActive(request.getActive());
		Inventory response=inventoryRepo.save(inventory);
		return mapToResponse(response);
	}

	private InventoryResponseDTO mapToResponse(Inventory inventory) {
	    InventoryResponseDTO dto = new InventoryResponseDTO();
	    dto.setId(inventory.getId());
	    dto.setProductId(inventory.getProductId());
	    dto.setProductName(inventory.getProductName());
	    dto.setQuantity(inventory.getQuantity());
	    dto.setStatus(inventory.getStatus());
	    dto.setActive(inventory.getActive());
	    return dto;
	}
	 @PostConstruct
	    public void loadInventoryToRedis() {
	        List<Inventory> inventories = inventoryRepo.findAll();

	        for (Inventory inv : inventories) {
	            redisService.setStock(
	                inv.getProductId(),
	                inv.getQuantity()
	            );
	        }

	        System.out.println("âœ… Inventory loaded into Redis");
	    }

	@Transactional
	public List<InventoryResponseDTO> reduceInventoryBulk(
	        List<InventoryReduceRequestDTO> requests) {

	    List<InventoryResponseDTO> responses = new ArrayList<>();

	    // 1ï¸âƒ£ First validation (NO UPDATE YET)
	    for (InventoryReduceRequestDTO req : requests) {
	        Inventory inventory = inventoryRepo.findByProductId(req.getProductId())
	            .orElseThrow(() -> new RuntimeException(
	                "Inventory not found for productId: " + req.getProductId()));

	        if (!inventory.getActive()) {
	            throw new RuntimeException(
	                "Product inactive: " + req.getProductId());
	        }

	        if (inventory.getQuantity() < req.getQuantity()) {
	            throw new RuntimeException(
	                "Insufficient stock for productId: " + req.getProductId()
	                + ", available: " + inventory.getQuantity());
	        }
	    }

	    // 2ï¸âƒ£ Actual reduce (SAFE)
	    for (InventoryReduceRequestDTO req : requests) {
	    	Inventory inventory = inventoryRepo.findByProductId(req.getProductId()).get();

	        int remainingQty = inventory.getQuantity() - req.getQuantity();
	        inventory.setQuantity(remainingQty);
	        inventory.updateStatus();

	        Inventory saved = inventoryRepo.save(inventory);
	        responses.add(mapToResponse(saved));

	        // ðŸ”¥ OUT OF STOCK â†’ deactivate product
	        if (remainingQty == 0) {
	            productClient.deactivateProduct(inventory.getProductId());
	            inventory.setActive(false); // inventory bhi inactive
	        }
	    }

	    return responses;
	}


	public InventoryResponseDTO restockInventory(InventoryRestockRequestDTO request) {
		 Inventory inventory = inventoryRepo.findByProductId(request.getProductId())
		            .orElseThrow(() -> new RuntimeException("Inventory not found for productId: " + request.getProductId()));
          int newQuantity=request.getQuantity()+inventory.getQuantity();
          inventory.setQuantity(newQuantity);
          inventory.updateStatus();
          Inventory savedInventory = inventoryRepo.save(inventory);
          return mapToResponse(savedInventory); 
		
	}
	public List<InventoryCheckResponseDTO> checkStock(
	        List<InventoryCheckRequestDTO> requests) {

	    List<InventoryCheckResponseDTO> responses = new ArrayList<>();

	    for (InventoryCheckRequestDTO req : requests) {

	        Inventory inventory = inventoryRepo
	                .findByProductId(req.getProductId())
	                .orElse(null);

	        InventoryCheckResponseDTO res = new InventoryCheckResponseDTO();
	        res.setProductId(req.getProductId());

	        if (inventory == null || !inventory.getActive()) {
	            res.setAvailable(false);
	            res.setMessage("Product not available in inventory");
	        }
	        else if (inventory.getQuantity() < req.getRequiredQuantity()) {
	            res.setAvailable(false);
	            res.setAvailableQuantity(inventory.getQuantity());
	            res.setMessage("Insufficient stock");
	        }
	        else {
	            res.setAvailable(true);
	            res.setAvailableQuantity(inventory.getQuantity());
	            res.setMessage("Stock available");
	        }

	        responses.add(res);
	    }

	    return responses;
	}



}
